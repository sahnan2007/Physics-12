<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 4: The Wave Nature of Light - Interactive Outline</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }
        header {
            background-color: #333;
            color: #fff;
            padding: 1rem 0;
            text-align: center;
        }
        nav {
            background-color: #444;
            padding: 0.5rem;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        nav ul li {
            display: inline-block;
            margin: 0 5px;
        }
        nav a {
            color: #fff;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 3px;
            transition: background-color 0.3s;
        }
        nav a:hover, nav a.active {
            background-color: #555;
        }
        main {
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        section {
            margin-bottom: 30px;
            padding-top: 60px; /* Offset for sticky nav */
            margin-top: -60px; /* Negative margin to counteract padding */
            border-bottom: 1px solid #eee;
            padding-bottom: 20px;
        }
        h2 {
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 5px;
        }
        h3 {
            color: #555;
            margin-top: 1.5em;
        }
        canvas {
            border: 1px solid #ccc;
            display: block;
            margin: 15px auto;
            background-color: #f0f8ff; /* Light blue background for canvases */
        }
        .controls {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-radius: 5px;
        }
        .controls label {
            margin-right: 10px;
            min-width: 120px;
            display: inline-block;
        }
        .controls input[type="range"] {
            width: 150px;
            vertical-align: middle;
        }
        .controls span {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            font-weight: bold;
            margin-left: 5px;
        }
        code {
            background-color: #eee;
            padding: 2px 4px;
            border-radius: 3px;
        }
        ul {
            margin-left: 20px;
        }
    </style>
</head>
<body>

    <header>
        <h1>Physics 12 University SPH 4U0</h1>
        <h2>Unit 4: The Wave Nature of Light</h2>
    </header>

    <nav id="navbar">
        <ul>
            <li><a href="#s9-1">9.1 Waves</a></li>
            <li><a href="#s9-2">9.2 Refraction</a></li>
            <li><a href="#s9-3">9.3 Water Waves</a></li>
            <li><a href="#s9-4">9.4 Wave/Particle</a></li>
            <li><a href="#s9-5">9.5 Double Slit</a></li>
            <li><a href="#s10-1">10.1 Thin Films</a></li>
            <li><a href="#s10-2">10.2 Single Slit</a></li>
            <li><a href="#s10-3">10.3 Grating</a></li>
            <li><a href="#s10-4">10.4 EM Radiation</a></li>
            <li><a href="#s10-5">10.5 Polarization</a></li>
        </ul>
    </nav>

    <main>
        <section id="s9-1">
            <h2>9.1 Properties of Waves and Light (p 440)</h2>
            <p>Waves transfer energy without transferring matter. Key properties include:</p>
            <ul>
                <li><strong>Periodicity:</strong> The wave pattern repeats over time (period, T) and space (wavelength, λ).</li>
                <li><strong>Wave Front:</strong> A line or surface connecting points of constant phase.</li>
                <li><strong>Crest & Trough:</strong> Highest and lowest points of a transverse wave.</li>
                <li><strong>Wavelength (λ):</strong> Distance between two consecutive crests or troughs.</li>
                <li><strong>Amplitude (A):</strong> Maximum displacement from the equilibrium position.</li>
                <li><strong>Phase:</strong> Position within a cycle.</li>
                <li><strong>Period (T):</strong> Time for one complete cycle.</li>
                <li><strong>Frequency (f):</strong> Number of cycles per second (f = 1/T).</li>
                <li><strong>Universal Wave Equation:</strong> <code>v = fλ</code> (speed = frequency × wavelength).</li>
                <li><strong>Reflection:</strong> Bouncing of waves off a surface. Angle of incidence (θi) equals angle of reflection (θr).</li>
                <li><strong>Specular vs. Diffuse Reflection:</strong> Reflection from smooth vs. rough surfaces.</li>
            </ul>
            <h3>Interactive Wave Visualization</h3>
            <div class="controls">
                <label for="amplitudeSlider">Amplitude:</label>
                <input type="range" id="amplitudeSlider" min="10" max="50" value="30">
                <span id="amplitudeValue">30</span> px<br>
                <label for="wavelengthSlider">Wavelength:</label>
                <input type="range" id="wavelengthSlider" min="50" max="200" value="100">
                <span id="wavelengthValue">100</span> px
            </div>
            <canvas id="waveCanvas" width="600" height="200"></canvas>
        </section>

        <section id="s9-2">
            <h2>9.2 Refraction and Total Internal Reflection (p 444)</h2>
            <p>Refraction is the bending of a wave as it passes from one medium to another, due to a change in speed.</p>
            <ul>
                <li><strong>Optical Density & Index of Refraction (n):</strong> Measure of how much light slows down in a medium (<code>n = c/v</code>, where c is speed of light in vacuum).</li>
                <li><strong>Snell's Law:</strong> Relates angles of incidence (θ₁) and refraction (θ₂) to indices of refraction (n₁ and n₂): <code>n₁ sin(θ₁) = n₂ sin(θ₂)</code>.</li>
                <li><strong>Dispersion:</strong> Separation of white light into colors because the index of refraction varies slightly with wavelength (e.g., prisms).</li>
                <li><strong>Total Internal Reflection (TIR):</strong> Occurs when light travels from a denser (higher n) to a less dense (lower n) medium at an angle of incidence greater than the critical angle (θc). At θc, the refracted angle is 90°. For θ₁ > θc, all light is reflected. <code>sin(θc) = n₂ / n₁</code> (where n₁ > n₂).</li>
            </ul>
             <h3>Interactive Refraction & TIR Simulation</h3>
             <div class="controls">
                 <label for="angleSlider">Angle of Incidence:</label>
                 <input type="range" id="angleSlider" min="0" max="89" value="30">
                 <span id="angleValue">30</span>°<br>
                 <label for="n1Slider">Index n₁ (Top):</label>
                 <input type="range" id="n1Slider" min="1.0" max="2.5" step="0.01" value="1.00">
                 <span id="n1Value">1.00</span><br>
                 <label for="n2Slider">Index n₂ (Bottom):</label>
                 <input type="range" id="n2Slider" min="1.0" max="2.5" step="0.01" value="1.50">
                 <span id="n2Value">1.50</span>
             </div>
             <canvas id="refractionCanvas" width="600" height="300"></canvas>
             <p id="tirStatus" style="text-align: center; font-weight: bold; color: red;"></p>
        </section>

        <section id="s9-3">
            <h2>9.3 Diffraction & Interference of Water Waves (p 459)</h2>
            <p>Diffraction is the spreading of waves as they pass through an opening or around an obstacle. Interference occurs when two or more waves overlap.</p>
            <ul>
                <li><strong>Diffraction Dependence:</strong> Diffraction is most noticeable when the wavelength (λ) is comparable to or larger than the slit width (w). Wider slit or shorter wavelength = less diffraction.</li>
                <li><strong>Interference Patterns:</strong> When waves from two coherent sources overlap, they interfere.
                    <ul>
                        <li><strong>Constructive Interference:</strong> Crest meets crest, trough meets trough (waves in phase). Results in larger amplitude (maxima/bright bands). Path difference is <code>nλ</code>.</li>
                        <li><strong>Destructive Interference:</strong> Crest meets trough (waves out of phase). Results in zero or smaller amplitude (minima/dark bands). Path difference is <code>(n + 1/2)λ</code>.</li>
                    </ul>
                </li>
                <li><strong>Maxima and Minima Bands:</strong> Observable pattern of alternating high and low intensity.</li>
            </ul>
            <h3>Simplified Diffraction/Interference Visualization</h3>
            <div class="controls">
                 <label for="slitWidthSlider">Slit Width (w):</label>
                 <input type="range" id="slitWidthSlider" min="1" max="20" value="5">
                 <span id="slitWidthValue">5</span> (relative units)<br>
                 <label for="waterWavelengthSlider">Wavelength (λ):</label>
                 <input type="range" id="waterWavelengthSlider" min="1" max="10" value="5">
                 <span id="waterWavelengthValue">5</span> (relative units)
            </div>
             <p>(Note: This is a highly simplified representation)</p>
             <canvas id="diffractionCanvas" width="600" height="250"></canvas>
        </section>

        <section id="s9-4">
            <h2>9.4 Light: Wave or Particle? (p 470)</h2>
            <p>Historically, there were competing theories about the nature of light.</p>
            <ul>
                 <li><strong>Newton's Particle Theory (Corpuscular Theory):</strong> Proposed light consists of tiny particles (corpuscles). Explained reflection and refraction (though incorrectly predicted speed increase in denser media). Couldn't easily explain diffraction or interference.</li>
                 <li><strong>Huygens' Principle:</strong> Proposed that every point on a wavefront acts as a source of secondary spherical wavelets. The new wavefront is the tangent envelope to these wavelets. Successfully explained reflection, refraction, and diffraction.</li>
                 <li><strong>Huygens' Wave Theory:</strong> Based on his principle, treated light as a wave phenomenon. Became the dominant theory after experiments showed interference and diffraction.</li>
                 <li><strong>Modern View (Wave-Particle Duality):</strong> Light exhibits both wave-like (interference, diffraction) and particle-like (photoelectric effect) properties. It's described by quantum mechanics.</li>
            </ul>
            <h3>Huygens' Principle Animation</h3>
            <p>Each point on a wavefront acts as a source of new spherical wavelets. The envelope tangent to these wavelets forms the next wavefront. Watch how a plane wave propagates and diffracts through a slit.</p>
             <div class="controls">
                <button id="huygensPlayPause">Pause</button>
                <label for="huygensSpeed">Speed:</label>
                <input type="range" id="huygensSpeed" min="0.1" max="2" step="0.1" value="0.5">
                <label for="huygensSlitWidth">Slit Width:</label>
                <input type="range" id="huygensSlitWidth" min="0" max="200" step="10" value="80">
                <span id="huygensSlitWidthValue">80</span> px
                <input type="checkbox" id="huygensShowSlit" checked>
                <label for="huygensShowSlit">Show Slit</label>
             </div>
             <canvas id="huygensCanvas" width="600" height="300"></canvas>
        </section>

        <section id="s9-5">
            <h2>9.5 Interference of Light Waves: Young's Double-Slit Experiment (p 477)</h2>
            <p>Thomas Young's experiment provided strong evidence for the wave nature of light.</p>
            <ul>
                <li><strong>Setup:</strong> Light passes through two narrow, closely spaced slits, illuminating a screen behind them.</li>
                <li><strong>Observation:</strong> An interference pattern of alternating bright (constructive interference) and dark (destructive interference) fringes appears on the screen.</li>
                <li><strong>Path Difference:</strong> The difference in distance traveled by light from each slit to a point on the screen determines whether interference is constructive or destructive. Path difference ≈ <code>d sin(θ)</code>, where d is slit separation and θ is the angle to the point on the screen.</li>
                <li><strong>Equations (for small angles):</strong>
                    <ul>
                        <li>Bright Fringes (Maxima): <code>x_m = (mλL) / d</code> or <code>d sin(θ) = mλ</code></li>
                        <li>Dark Fringes (Minima): <code>x_m = ((m + 1/2)λL) / d</code> or <code>d sin(θ) = (m + 1/2)λ</code></li>
                        (m = 0, ±1, ±2, ...; L = distance to screen; x_m = position on screen)
                    </ul>
                </li>
            </ul>
            <h3>Double Slit Interference Pattern Simulation</h3>
            <div class="controls">
                 <label for="doubleSlitLambdaSlider">Wavelength (λ):</label>
                 <input type="range" id="doubleSlitLambdaSlider" min="400" max="700" value="550">
                 <span id="doubleSlitLambdaValue">550</span> nm<br>
                 <label for="doubleSlitDSlider">Slit Separation (d):</label>
                 <input type="range" id="doubleSlitDSlider" min="0.05" max="0.5" step="0.01" value="0.15">
                 <span id="doubleSlitDValue">0.15</span> mm
            </div>
             <p>(Screen distance L is fixed in this simulation)</p>
             <canvas id="doubleSlitCanvas" width="600" height="150"></canvas>
        </section>

                <section id="s10-1">
            <h2>10.1 Interference in Thin Films (p 502)</h2>
            <p>Colors seen in soap bubbles or oil slicks are due to interference of light waves reflecting off the top and bottom surfaces of a thin film. The interference depends on the film thickness, its index of refraction, the wavelength of light, and phase changes upon reflection.</p>
            <ul>
                <li><strong>Phase Change on Reflection:</strong> A 180° (or λ/2) phase change occurs when light reflects from a medium with a *higher* index of refraction. No phase change occurs if reflecting from a medium with a *lower* index.</li>
                <li><strong>Path Difference:</strong> Light reflecting from the bottom surface travels an extra distance (approximately 2t for normal incidence) within the film. The wavelength inside the film is λ/n_film.</li>
                <li><strong>Interference:</strong> The combination of path difference and phase shifts determines if wavelengths interfere constructively (bright reflection) or destructively (dark reflection).</li>
            </ul>
            <h3>Thin Film Interference Color Simulation (Normal Incidence)</h3>
            <div class="controls">
                <label for="filmThicknessSlider">Film Thickness (t):</label>
                <input type="range" id="filmThicknessSlider" min="0" max="1000" value="200" step="5">
                <span id="filmThicknessValue">200</span> nm<br>
                <label for="filmIndexSlider">Film Index (n_film):</label>
                <input type="range" id="filmIndexSlider" min="1.0" max="2.5" step="0.01" value="1.33">
                <span id="filmIndexValue">1.33</span><br>
                <label>Incident Medium Index (n_inc):</label>
                <span>1.00 (Air)</span><br> <!-- Assuming Air -->
                 <label for="substrateIndexSlider">Substrate Index (n_sub):</label>
                 <input type="range" id="substrateIndexSlider" min="1.0" max="2.5" step="0.01" value="1.50">
                 <span id="substrateIndexValue">1.50</span>
            </div>
            <canvas id="thinFilmCanvas" width="600" height="250"></canvas>
            <div style="display: flex; justify-content: space-around; margin-top: 10px;">
                 <div style="text-align: center;">
                    <p><b>Calculated Reflected Color:</b></p>
                    <div id="reflectedColorBox" style="width: 100px; height: 50px; border: 1px solid black; margin: 0 auto;"></div>
                 </div>
                 <div id="filmInterferenceResult" style="text-align: left; max-width: 300px;">
                     <p><b>Interference Details:</b></p>
                     <span id="interferenceText"></span>
                 </div>
            </div>
        </section>

        <section id="s10-2">
            <h2>10.2 Single Slit Diffraction (p 512)</h2>
            <p>When light passes through a single narrow slit, it diffracts, creating a pattern with a wide, bright central maximum and progressively weaker, narrower maxima on either side, separated by minima (dark fringes).</p>
            <ul>
                <li><strong>Pattern Characteristics:</strong> The central maximum is twice as wide as the secondary maxima. Intensity decreases rapidly for higher-order maxima.</li>
                <li><strong>Explanation (Huygens' Principle):</strong> Each point across the slit acts as a wavelet source. Interference between these wavelets creates the pattern. Minima occur when wavelets from different parts of the slit interfere destructively.</li>
                <li><strong>Condition for Minima:</strong> Dark fringes occur at angles θ where <code>w sin(θ) = mλ</code> (m = ±1, ±2, ±3, ...; w = slit width). Note m=0 is the central maximum, not a minimum.</li>
            </ul>
             <h3>Single Slit Diffraction Pattern Simulation</h3>
             <div class="controls">
                  <label for="singleSlitLambdaSlider">Wavelength (λ):</label>
                  <input type="range" id="singleSlitLambdaSlider" min="400" max="700" value="500">
                  <span id="singleSlitLambdaValue">500</span> nm<br>
                  <label for="singleSlitWidthSlider">Slit Width (w):</label>
                  <input type="range" id="singleSlitWidthSlider" min="0.001" max="0.02" step="0.001" value="0.005">
                  <span id="singleSlitWidthValue">0.005</span> mm
             </div>
              <p>(Screen distance L is fixed in this simulation)</p>
              <canvas id="singleSlitCanvas" width="600" height="150"></canvas>
        </section>

        <section id="s10-3">
            <h2>10.3 The Diffraction Grating (p 520)</h2>
            <p>A diffraction grating consists of a large number of equally spaced parallel slits or lines. It produces much sharper and more widely separated interference maxima compared to a double slit.</p>
            <ul>
                <li><strong>Principle:</strong> Combines diffraction from each slit with multi-slit interference.</li>
                <li><strong>Result:</strong> Very bright, sharp principal maxima at specific angles, with broad regions of near-zero intensity in between.</li>
                <li><strong>Condition for Maxima:</strong> Bright fringes (principal maxima) occur at angles θ where <code>d sin(θ) = mλ</code> (m = 0, ±1, ±2, ...; d = distance between adjacent slits/lines, the grating spacing).</li>
                <li><strong>Applications:</strong> Used in spectrometers to separate light into its component wavelengths with high precision.</li>
            </ul>
            <h3>Diffraction Grating Pattern Simulation</h3>
            <div class="controls">
                 <label for="gratingLambdaSlider">Wavelength (λ):</label>
                 <input type="range" id="gratingLambdaSlider" min="400" max="700" value="600">
                 <span id="gratingLambdaValue">600</span> nm<br>
                 <label for="gratingDSlider">Grating Spacing (d):</label>
                 <input type="range" id="gratingDSlider" min="1000" max="5000" step="100" value="2000">
                 <span id="gratingDValue">2000</span> nm (lines/mm = 1/d)
            </div>
             <p>(Intensity profile is simplified - shows sharp maxima locations)</p>
             <canvas id="gratingCanvas" width="600" height="150"></canvas>
        </section>

        <section id="s10-4">
            <h2>10.4 Electromagnetic Radiation (p 526)</h2>
            <p>Light is a form of electromagnetic (EM) radiation, which consists of oscillating electric (E) and magnetic (B) fields propagating through space as transverse waves.</p>
            <ul>
                <li><strong>Properties:</strong>
                    <ul>
                        <li>Transverse waves: E and B fields are perpendicular to each other and to the direction of propagation.</li>
                        <li>Travel at the speed of light (c) in a vacuum (c ≈ 3.00 × 10⁸ m/s).</li>
                        <li>Carry energy and momentum.</li>
                        <li>Do not require a medium to travel.</li>
                        <li>Relationship: <code>c = fλ</code></li>
                    </ul>
                </li>
                <li><strong>Electromagnetic Spectrum:</strong> The full range of EM radiation, classified by wavelength/frequency. Includes (from long λ / low f to short λ / high f): radio waves, microwaves, infrared, visible light, ultraviolet, X-rays, gamma rays. Visible light is only a tiny portion.</li>
            </ul>
            <h3>Electromagnetic Wave Visualization</h3>
            <canvas id="emWaveCanvas" width="600" height="250"></canvas>
            <div class="controls">
               <button id="animateEMWaveButton">Animate/Pause</button>
               <label for="emWaveSpeedSlider">Animation Speed:</label>
               <input type="range" id="emWaveSpeedSlider" min="0.1" max="2" step="0.1" value="0.5">
            </div>
        </section>

        <section id="s10-5">
            <h2>10.5 Polarization of Light (p 532)</h2>
            <p>Polarization refers to the orientation of the electric field oscillations of a transverse wave, like light.</p>
            <ul>
                <li><strong>Unpolarized Light:</strong> E-field oscillates randomly in all directions perpendicular to propagation (e.g., light from the sun or a light bulb).</li>
                <li><strong>Polarized Light (Linearly Polarized):</strong> E-field oscillates in only one specific plane.</li>
                <li><strong>Polarizers:</strong> Materials that transmit light with E-field oscillations aligned along a specific transmission axis, absorbing or reflecting oscillations perpendicular to that axis.</li>
                <li><strong>Analyzers:</strong> A second polarizer used to determine if light is polarized and its plane of polarization.</li>
                <li><strong>Malus's Law:</strong> When linearly polarized light of intensity I₀ passes through an analyzer whose transmission axis is at an angle θ relative to the light's polarization plane, the transmitted intensity I is given by: <code>I = I₀ cos²(θ)</code>.</li>
                <li><strong>Methods of Polarization:</strong>
                    <ul>
                        <li><strong>Selective Absorption (Polaroid filters):</strong> Use materials that absorb light polarized in one direction more than another.</li>
                        <li><strong>Reflection:</strong> Reflected light is partially or fully polarized, especially at Brewster's angle.</li>
                        <li><strong>Scattering:</strong> Light scattered by small particles (like air molecules) becomes partially polarized (why the sky is blue and polarized).</li>
                        <li><strong>Birefringence (Double Refraction):</strong> Some crystals split unpolarized light into two polarized beams.</li>
                    </ul>
                </li>
            </ul>
            <h3>Polarization Simulation (Polarizer & Analyzer)</h3>
            <div class="controls">
                 <label for="analyzerAngleSlider">Analyzer Angle (θ):</label>
                 <input type="range" id="analyzerAngleSlider" min="0" max="180" value="0">
                 <span id="analyzerAngleValue">0</span>°
            </div>
             <p>Unpolarized light -> Ideal Polarizer (Vertical) -> Analyzer -> Output</p>
             <canvas id="polarizationCanvas" width="600" height="150"></canvas>
             <p id="malusResult" style="text-align: center; font-weight: bold;"></p>
        </section>

    </main>

    <script>
        // --- Utility Functions ---
        function degreesToRadians(degrees) {
            return degrees * Math.PI / 180;
        }

        function radiansToDegrees(radians) {
            return radians * 180 / Math.PI;
        }

        // --- 9.1 Properties of Waves ---
        const waveCanvas = document.getElementById('waveCanvas');
        const waveCtx = waveCanvas.getContext('2d');
        const amplitudeSlider = document.getElementById('amplitudeSlider');
        const wavelengthSlider = document.getElementById('wavelengthSlider');
        const amplitudeValue = document.getElementById('amplitudeValue');
        const wavelengthValue = document.getElementById('wavelengthValue');
        let wavePhase = 0;

        function drawWave() {
            const width = waveCanvas.width;
            const height = waveCanvas.height;
            const amplitude = parseInt(amplitudeSlider.value);
            const wavelength = parseInt(wavelengthSlider.value);
            const k = 2 * Math.PI / wavelength; // Wave number
            const omega = 0.05; // Angular frequency for animation (arbitrary)

            amplitudeValue.textContent = amplitude;
            wavelengthValue.textContent = wavelength;

            waveCtx.clearRect(0, 0, width, height);
            waveCtx.strokeStyle = '#007bff';
            waveCtx.lineWidth = 2;
            waveCtx.beginPath();
            waveCtx.moveTo(0, height / 2);

            for (let x = 0; x < width; x++) {
                const y = height / 2 + amplitude * Math.sin(k * x + wavePhase);
                waveCtx.lineTo(x, y);
            }
            waveCtx.stroke();

            // Draw equilibrium line
            waveCtx.strokeStyle = '#ccc';
            waveCtx.lineWidth = 1;
            waveCtx.beginPath();
            waveCtx.moveTo(0, height / 2);
            waveCtx.lineTo(width, height / 2);
            waveCtx.stroke();

             // Draw Amplitude and Wavelength indicators (simplified)
             waveCtx.fillStyle = 'red';
             waveCtx.fillText(`Amplitude (A = ${amplitude}px)`, 10, 20);
             waveCtx.fillText(`Wavelength (λ = ${wavelength}px)`, width - 150, 20);

             // Draw crest/trough indicator (approximate)
             let firstCrestX = -1;
             for (let x = 0; x < width; x++) {
                 if (Math.sin(k * x + wavePhase) > 0.98) { firstCrestX = x; break; }
             }
             if(firstCrestX > 0) {
                 waveCtx.fillText('Crest', firstCrestX - 15, height/2 - amplitude - 5);
                 waveCtx.beginPath();
                 waveCtx.moveTo(firstCrestX, height/2);
                 waveCtx.lineTo(firstCrestX + wavelength, height/2);
                 waveCtx.stroke(); // For wavelength line
                 waveCtx.fillText('λ', firstCrestX + wavelength/2 - 5, height/2 + 15);

                 waveCtx.beginPath();
                 waveCtx.moveTo(firstCrestX, height/2);
                 waveCtx.lineTo(firstCrestX, height/2 - amplitude);
                 waveCtx.stroke(); // For amplitude line
                 waveCtx.fillText('A', firstCrestX + 5, height/2 - amplitude/2);
             }

             wavePhase += omega; // Simple animation progression
        }

        amplitudeSlider.addEventListener('input', drawWave);
        wavelengthSlider.addEventListener('input', drawWave);
        //setInterval(drawWave, 50); // Animate the wave
        drawWave(); // Initial draw

        // --- 9.2 Refraction & TIR ---
        const refractionCanvas = document.getElementById('refractionCanvas');
        const refractionCtx = refractionCanvas.getContext('2d');
        const angleSlider = document.getElementById('angleSlider');
        const n1Slider = document.getElementById('n1Slider');
        const n2Slider = document.getElementById('n2Slider');
        const angleValue = document.getElementById('angleValue');
        const n1Value = document.getElementById('n1Value');
        const n2Value = document.getElementById('n2Value');
        const tirStatus = document.getElementById('tirStatus');

        function drawRefraction() {
            const width = refractionCanvas.width;
            const height = refractionCanvas.height;
            const interfaceY = height / 2;
            const centerX = width / 3; // Point of incidence

            const angle1_deg = parseInt(angleSlider.value);
            const n1 = parseFloat(n1Slider.value);
            const n2 = parseFloat(n2Slider.value);
            const angle1_rad = degreesToRadians(angle1_deg);

            angleValue.textContent = angle1_deg;
            n1Value.textContent = n1.toFixed(2);
            n2Value.textContent = n2.toFixed(2);
            tirStatus.textContent = ''; // Clear status initially

            refractionCtx.clearRect(0, 0, width, height);

            // Draw media
            refractionCtx.fillStyle = 'rgba(173, 216, 230, 0.3)'; // Light blue top
            refractionCtx.fillRect(0, 0, width, interfaceY);
            refractionCtx.fillStyle = 'rgba(144, 238, 144, 0.3)'; // Light green bottom
            refractionCtx.fillRect(0, interfaceY, width, height - interfaceY);
            refractionCtx.fillStyle = '#000';
            refractionCtx.fillText(`n₁ = ${n1.toFixed(2)}`, 10, 20);
            refractionCtx.fillText(`n₂ = ${n2.toFixed(2)}`, 10, height - 10);


            // Draw interface & normal
            refractionCtx.strokeStyle = '#000';
            refractionCtx.lineWidth = 2;
            refractionCtx.beginPath();
            refractionCtx.moveTo(0, interfaceY);
            refractionCtx.lineTo(width, interfaceY);
            refractionCtx.stroke();

            refractionCtx.strokeStyle = '#888';
            refractionCtx.lineWidth = 1;
            refractionCtx.setLineDash([5, 5]);
            refractionCtx.beginPath();
            refractionCtx.moveTo(centerX, 0);
            refractionCtx.lineTo(centerX, height);
            refractionCtx.stroke();
            refractionCtx.setLineDash([]); // Reset dash

            // Calculate incident ray endpoint
            const incidentLength = interfaceY / Math.cos(angle1_rad);
            const incidentEndX = centerX - incidentLength * Math.sin(angle1_rad);
            const incidentEndY = 0;

            // Draw incident ray
            refractionCtx.strokeStyle = 'red';
            refractionCtx.lineWidth = 2;
            refractionCtx.beginPath();
            refractionCtx.moveTo(incidentEndX, incidentEndY);
            refractionCtx.lineTo(centerX, interfaceY);
            refractionCtx.stroke();
            refractionCtx.fillText(`θ₁=${angle1_deg}°`, centerX - 40, interfaceY - 10);

            // Draw reflected ray (angle1 = angle_reflection)
            const reflectedEndX = centerX + incidentLength * Math.sin(angle1_rad);
            const reflectedEndY = 0;
            refractionCtx.strokeStyle = 'orange';
             refractionCtx.lineWidth = 1.5;
            refractionCtx.beginPath();
            refractionCtx.moveTo(centerX, interfaceY);
            refractionCtx.lineTo(reflectedEndX, reflectedEndY);
            refractionCtx.stroke();


            // Calculate refraction angle using Snell's Law
            const sin_angle2 = (n1 / n2) * Math.sin(angle1_rad);

            if (Math.abs(sin_angle2) <= 1) {
                const angle2_rad = Math.asin(sin_angle2);
                const angle2_deg = radiansToDegrees(angle2_rad);

                // Draw refracted ray
                const refractedLength = (height - interfaceY) / Math.cos(angle2_rad);
                const refractedEndX = centerX + refractedLength * Math.sin(angle2_rad);
                const refractedEndY = height;

                refractionCtx.strokeStyle = 'blue';
                 refractionCtx.lineWidth = 2;
                refractionCtx.beginPath();
                refractionCtx.moveTo(centerX, interfaceY);
                refractionCtx.lineTo(refractedEndX, refractedEndY);
                refractionCtx.stroke();
                refractionCtx.fillText(`θ₂=${angle2_deg.toFixed(1)}°`, centerX + 10, interfaceY + 20);

            } else {
                // Total Internal Reflection
                 tirStatus.textContent = 'Total Internal Reflection Occurring!';
                 // Reflected ray already drawn, maybe make it thicker?
                 refractionCtx.strokeStyle = 'orange';
                 refractionCtx.lineWidth = 3;
                 refractionCtx.beginPath();
                 refractionCtx.moveTo(centerX, interfaceY);
                 refractionCtx.lineTo(reflectedEndX, reflectedEndY);
                 refractionCtx.stroke();

                 // Calculate critical angle for display
                 if (n1 > n2) {
                    const criticalAngleRad = Math.asin(n2 / n1);
                    const criticalAngleDeg = radiansToDegrees(criticalAngleRad);
                    tirStatus.textContent += ` (Critical Angle θc = ${criticalAngleDeg.toFixed(1)}°)`;
                 }
            }
        }

        angleSlider.addEventListener('input', drawRefraction);
        n1Slider.addEventListener('input', drawRefraction);
        n2Slider.addEventListener('input', drawRefraction);
        drawRefraction(); // Initial draw

        // --- 9.3 Water Wave Diffraction ---
        const diffractionCanvas = document.getElementById('diffractionCanvas');
        const diffractionCtx = diffractionCanvas.getContext('2d');
        const slitWidthSlider = document.getElementById('slitWidthSlider');
        const waterWavelengthSlider = document.getElementById('waterWavelengthSlider');
        const slitWidthValue = document.getElementById('slitWidthValue');
        const waterWavelengthValue = document.getElementById('waterWavelengthValue');

        function drawDiffraction() {
            const width = diffractionCanvas.width;
            const height = diffractionCanvas.height;
            const slitWidth = parseInt(slitWidthSlider.value) * 5; // Scale factor
            const wavelength = parseInt(waterWavelengthSlider.value) * 5; // Scale factor
            const barrierX = width / 3;
            const slitY_center = height / 2;
            const slitTop = slitY_center - slitWidth / 2;
            const slitBottom = slitY_center + slitWidth / 2;

            slitWidthValue.textContent = slitWidthSlider.value;
            waterWavelengthValue.textContent = waterWavelengthSlider.value;

            diffractionCtx.clearRect(0, 0, width, height);

            // Draw barrier
            diffractionCtx.fillStyle = '#666';
            diffractionCtx.fillRect(barrierX - 5, 0, 10, slitTop);
            diffractionCtx.fillRect(barrierX - 5, slitBottom, 10, height - slitBottom);

            // Draw incoming plane waves (simplified)
            diffractionCtx.strokeStyle = '#007bff';
            diffractionCtx.lineWidth = 1;
            for (let x = barrierX - wavelength; x > 0; x -= wavelength) {
                diffractionCtx.beginPath();
                diffractionCtx.moveTo(x, 0);
                diffractionCtx.lineTo(x, height);
                diffractionCtx.stroke();
            }

             // Draw diffracted waves (highly simplified - just arcs)
             const numArcs = Math.floor((width - barrierX) / wavelength);
             const spreadFactor = wavelength / (slitWidth / 5); // More spread for smaller slit/longer wavelength

             diffractionCtx.strokeStyle = '#007bff';
             diffractionCtx.lineWidth = 1.5;
             for (let i = 1; i <= numArcs; i++) {
                 const radius = i * wavelength;
                 diffractionCtx.beginPath();
                 // Angle limits based on simplified diffraction idea
                 const maxAngle = Math.atan(spreadFactor) * 0.8; // Limit the spread angle
                 diffractionCtx.arc(barrierX, slitY_center, radius, -maxAngle, maxAngle);
                 diffractionCtx.stroke();
             }
        }

        slitWidthSlider.addEventListener('input', drawDiffraction);
        waterWavelengthSlider.addEventListener('input', drawDiffraction);
        drawDiffraction(); // Initial draw


        // --- 9.4 Enhanced Huygens' Principle ---
        const huygensCanvas = document.getElementById('huygensCanvas');
        const huygensCtx = huygensCanvas.getContext('2d');
        const huygensPlayPause = document.getElementById('huygensPlayPause');
        const huygensSpeedSlider = document.getElementById('huygensSpeed');
        const huygensSlitWidthSlider = document.getElementById('huygensSlitWidth');
        const huygensSlitWidthValue = document.getElementById('huygensSlitWidthValue');
        const huygensShowSlitCheckbox = document.getElementById('huygensShowSlit');

        let huygensWavefrontX = 10; // Starting X position of the plane wave
        const huygensWavefrontYStart = 10;
        const huygensWavefrontYEnd = huygensCanvas.height - 10;
        const huygensNumSources = 20; // Number of wavelet sources on the wavefront
        let huygensWaveletRadius = 0;
        const huygensMaxWaveletRadius = 25; // Distance wave travels per 'step'
        let huygensAnimationId = null;
        let huygensIsPlaying = true;

        function drawHuygensEnhanced() {
            const width = huygensCanvas.width;
            const height = huygensCanvas.height;
            const speed = parseFloat(huygensSpeedSlider.value);
            const showSlit = huygensShowSlitCheckbox.checked;
            const slitWidth = parseInt(huygensSlitWidthSlider.value);
            const slitX = width / 2;
            const slitY1 = (height - slitWidth) / 2;
            const slitY2 = (height + slitWidth) / 2;

            huygensSlitWidthValue.textContent = slitWidth;

            huygensCtx.clearRect(0, 0, width, height);

            // --- Draw Barrier/Slit (Optional) ---
            if (showSlit) {
                huygensCtx.fillStyle = '#666';
                // Top part of barrier
                huygensCtx.fillRect(slitX - 5, 0, 10, slitY1);
                // Bottom part of barrier
                huygensCtx.fillRect(slitX - 5, slitY2, 10, height - slitY2);
            }

            // --- Draw Wavefront and Wavelets ---
            const sources = [];
            for (let i = 0; i <= huygensNumSources; i++) {
                const y = huygensWavefrontYStart + (i / huygensNumSources) * (huygensWavefrontYEnd - huygensWavefrontYStart);
                let currentX = huygensWavefrontX;

                // Check if this point is blocked by the slit barrier BEFORE it reaches the slit
                 if (showSlit && currentX < slitX && (y < slitY1 || y > slitY2)) {
                     continue; // Don't draw source if blocked before slit
                 }
                 // Check if this point is blocked AFTER passing the slit x-position
                 if (showSlit && currentX >= slitX && (y < slitY1 || y > slitY2)) {
                     continue; // Stop propagation if hits barrier
                 }

                 sources.push({ x: currentX, y: y });

                // Draw wavelet source point on the wavefront
                huygensCtx.fillStyle = 'blue';
                huygensCtx.beginPath();
                huygensCtx.arc(currentX, y, 2, 0, 2 * Math.PI);
                huygensCtx.fill();

                // Draw expanding wavelet
                huygensCtx.strokeStyle = 'rgba(0, 180, 255, 0.4)';
                huygensCtx.lineWidth = 1;
                huygensCtx.beginPath();
                huygensCtx.arc(currentX, y, huygensWaveletRadius, 0, 2 * Math.PI);
                huygensCtx.stroke();
            }

             // --- Draw the "Envelope" (Next Wavefront approximation) ---
             if (sources.length > 1) {
                 huygensCtx.strokeStyle = 'blue';
                 huygensCtx.lineWidth = 2.5;
                 huygensCtx.beginPath();
                 // For plane wave, the envelope is simply shifted forward
                 let envelopeX = huygensWavefrontX + huygensWaveletRadius;

                 // Adjust envelope drawing if passing through slit
                 let firstSourceY = -1, lastSourceY = -1;
                 if (showSlit && envelopeX > slitX) {
                     for(const src of sources) {
                         if (src.y >= slitY1 && src.y <= slitY2) {
                             if (firstSourceY < 0) firstSourceY = src.y;
                             lastSourceY = src.y;
                         }
                     }
                 } else {
                     firstSourceY = sources[0].y;
                     lastSourceY = sources[sources.length - 1].y;
                 }

                 if (firstSourceY >= 0) {
                     // Draw envelope based on actual propagating sources
                     huygensCtx.moveTo(envelopeX, firstSourceY);
                     huygensCtx.lineTo(envelopeX, lastSourceY);

                     // Simple diffraction spread approximation after slit
                     if (showSlit && envelopeX > slitX + huygensMaxWaveletRadius) {
                        const spreadFactor = huygensMaxWaveletRadius / slitWidth; // Larger spread for smaller slit
                        const angle = Math.atan(spreadFactor * 0.5); // Approximate spread angle
                        const centerSlitY = (slitY1 + slitY2) / 2;
                        const distPastSlit = envelopeX - slitX;

                        // Draw diverging lines (very simplified diffraction)
                        huygensCtx.lineTo(slitX + distPastSlit / Math.cos(angle), centerSlitY + distPastSlit * Math.tan(angle));
                        huygensCtx.moveTo(envelopeX, firstSourceY); // Go back to start point
                        huygensCtx.lineTo(slitX + distPastSlit / Math.cos(angle), centerSlitY - distPastSlit * Math.tan(angle));

                     } else {
                         // Straight line before significant diffraction or if no slit
                          huygensCtx.lineTo(envelopeX, lastSourceY);
                     }


                 }
                 huygensCtx.stroke();

             }


            // --- Update Animation State ---
            huygensWaveletRadius += speed;
            if (huygensWaveletRadius >= huygensMaxWaveletRadius) {
                huygensWavefrontX += huygensMaxWaveletRadius; // Move wavefront forward
                huygensWaveletRadius = 0; // Reset wavelets

                // Reset wave if it goes off screen
                if (huygensWavefrontX > width + huygensMaxWaveletRadius) {
                    huygensWavefrontX = 10;
                }
            }

            // --- Loop Animation ---
            if (huygensIsPlaying) {
                huygensAnimationId = requestAnimationFrame(drawHuygensEnhanced);
            }
        }

        // --- Controls ---
        huygensPlayPause.addEventListener('click', () => {
            huygensIsPlaying = !huygensIsPlaying;
            huygensPlayPause.textContent = huygensIsPlaying ? 'Pause' : 'Play';
            if (huygensIsPlaying && huygensAnimationId === null) {
                huygensAnimationId = requestAnimationFrame(drawHuygensEnhanced);
            } else if (!huygensIsPlaying && huygensAnimationId !== null) {
                cancelAnimationFrame(huygensAnimationId);
                huygensAnimationId = null;
            }
        });

        // Make sliders update drawing without needing play/pause cycle
        huygensSpeedSlider.addEventListener('input', () => { if (!huygensIsPlaying) drawHuygensEnhanced(); });
        huygensSlitWidthSlider.addEventListener('input', () => { if (!huygensIsPlaying) drawHuygensEnhanced(); });
        huygensShowSlitCheckbox.addEventListener('change', () => { if (!huygensIsPlaying) drawHuygensEnhanced(); });


        // Start the animation
        huygensAnimationId = requestAnimationFrame(drawHuygensEnhanced);


        // --- 9.5 Young's Double Slit ---
        const doubleSlitCanvas = document.getElementById('doubleSlitCanvas');
        const doubleSlitCtx = doubleSlitCanvas.getContext('2d');
        const doubleSlitLambdaSlider = document.getElementById('doubleSlitLambdaSlider');
        const doubleSlitDSlider = document.getElementById('doubleSlitDSlider');
        const doubleSlitLambdaValue = document.getElementById('doubleSlitLambdaValue');
        const doubleSlitDValue = document.getElementById('doubleSlitDValue');

        function drawDoubleSlitPattern() {
            const width = doubleSlitCanvas.width;
            const height = doubleSlitCanvas.height;
            const lambda = parseInt(doubleSlitLambdaSlider.value) * 1e-9; // wavelength in m
            const d = parseFloat(doubleSlitDSlider.value) * 1e-3; // slit separation in m
            const L = 1.0; // Assume screen distance L = 1m for simplicity
            const scale = width / 0.05; // Scale: map +/- 2.5cm range to canvas width

            doubleSlitLambdaValue.textContent = doubleSlitLambdaSlider.value;
            doubleSlitDValue.textContent = doubleSlitDSlider.value;

            doubleSlitCtx.clearRect(0, 0, width, height);

             // Intensity calculation (approximate using cos^2 term)
             function getIntensity(x_screen) {
                const theta = Math.atan(x_screen / L); // Angle
                if (d === 0) return 1.0; // Avoid division by zero
                const phaseDifference = (2 * Math.PI * d * Math.sin(theta)) / lambda;
                // Interference term: cos^2(phaseDifference / 2)
                // We also need a single-slit diffraction envelope, but let's ignore it for simplicity
                const intensity = Math.pow(Math.cos(phaseDifference / 2), 2);
                return intensity;
             }

             // Draw the intensity pattern
             doubleSlitCtx.beginPath();
             doubleSlitCtx.moveTo(0, height);
             for (let i = 0; i < width; i++) {
                 const x_canvas = i;
                 // Convert canvas x to screen position y (relative to center)
                 const x_screen = (x_canvas - width / 2) / scale;
                 const intensity = getIntensity(x_screen);
                 const y_canvas = height - intensity * (height - 10); // Leave margin at top
                 doubleSlitCtx.lineTo(x_canvas, y_canvas);
             }
             // Fill the pattern area
             doubleSlitCtx.lineTo(width, height);
             doubleSlitCtx.closePath();

            // Create gradient based on wavelength
            const color = wavelengthToColor(parseInt(doubleSlitLambdaSlider.value));
            doubleSlitCtx.fillStyle = color;
            doubleSlitCtx.fill();

            // Draw center line
            doubleSlitCtx.strokeStyle = '#aaa';
            doubleSlitCtx.lineWidth = 1;
            doubleSlitCtx.beginPath();
            doubleSlitCtx.moveTo(width/2, 0);
            doubleSlitCtx.lineTo(width/2, height);
            doubleSlitCtx.stroke();
        }

        // Helper to get color from wavelength
        function wavelengthToColor(nm) {
            if (nm >= 380 && nm < 440) return `rgba(148, 0, 211, 0.7)`; // Violet
            else if (nm >= 440 && nm < 495) return `rgba(0, 0, 255, 0.7)`;    // Blue
            else if (nm >= 495 && nm < 570) return `rgba(0, 255, 0, 0.7)`;    // Green
            else if (nm >= 570 && nm < 590) return `rgba(255, 255, 0, 0.7)`;  // Yellow
            else if (nm >= 590 && nm < 620) return `rgba(255, 165, 0, 0.7)`; // Orange
            else if (nm >= 620 && nm <= 750) return `rgba(255, 0, 0, 0.7)`;   // Red
            else return `rgba(128, 128, 128, 0.7)`; // Gray for outside visible
        }


        doubleSlitLambdaSlider.addEventListener('input', drawDoubleSlitPattern);
        doubleSlitDSlider.addEventListener('input', drawDoubleSlitPattern);
        drawDoubleSlitPattern();

       // --- 10.1 Enhanced Thin Films ---
       const thinFilmCanvas = document.getElementById('thinFilmCanvas');
       const thinFilmCtx = thinFilmCanvas.getContext('2d');
       const filmThicknessSlider = document.getElementById('filmThicknessSlider');
       const filmIndexSlider = document.getElementById('filmIndexSlider');
       const substrateIndexSlider = document.getElementById('substrateIndexSlider'); // Added substrate slider
       const filmThicknessValue = document.getElementById('filmThicknessValue');
       const filmIndexValue = document.getElementById('filmIndexValue');
       const substrateIndexValue = document.getElementById('substrateIndexValue'); // Added substrate value display
       const reflectedColorBox = document.getElementById('reflectedColorBox');
       const interferenceText = document.getElementById('interferenceText');

       // Representative wavelengths for RGB
       const lambda_R = 650; // Red
       const lambda_G = 550; // Green
       const lambda_B = 450; // Blue

       function calculateThinFilmInterference(t_nm, n_inc, n_film, n_sub, lambda_nm) {
           // Phase shift at top surface (reflection 1)
           const phaseShift1_lambda = (n_film > n_inc) ? 0.5 : 0; // Phase shift in units of lambda

           // Phase shift at bottom surface (reflection 2)
           const phaseShift2_lambda = (n_sub > n_film) ? 0.5 : 0;

           // Optical path difference inside film (normal incidence)
           const pathDifference_nm = 2 * n_film * t_nm;
           const pathDifference_lambda = pathDifference_nm / lambda_nm;

           // Total phase difference between the two reflected waves (in units of lambda)
           const totalPhaseDifference_lambda = pathDifference_lambda + (phaseShift1_lambda - phaseShift2_lambda);

           // Calculate reflected intensity (amplitude squared). Using cos^2 model based on phase difference.
           // cos(PI * difference) ranges from -1 to 1. Squaring gives 0 to 1.
           // Phase difference of integer -> cos(n*PI) = +/-1 -> cos^2 = 1 (Constructive)
           // Phase difference of half-integer -> cos((n+0.5)*PI) = 0 -> cos^2 = 0 (Destructive)
           const reflectedAmplitude = Math.cos(Math.PI * totalPhaseDifference_lambda);
           const reflectedIntensity = Math.pow(reflectedAmplitude, 2);

           return {
               intensity: reflectedIntensity,
               phaseShift1: phaseShift1_lambda > 0,
               phaseShift2: phaseShift2_lambda > 0,
               pathDiff_nm: pathDifference_nm
           };
       }

       function getInterferenceDescription(intensity) {
           if (intensity > 0.9) return "Strongly Constructive";
           if (intensity > 0.6) return "Constructive";
           if (intensity < 0.1) return "Destructive";
           if (intensity < 0.4) return "Mostly Destructive";
           return "Intermediate";
       }


       function drawThinFilmEnhanced() {
           const width = thinFilmCanvas.width;
           const height = thinFilmCanvas.height;
           const t_nm = parseInt(filmThicknessSlider.value);
           const n_inc = 1.0; // Assuming Air
           const n_film = parseFloat(filmIndexSlider.value);
           const n_sub = parseFloat(substrateIndexSlider.value); // Use slider value

           filmThicknessValue.textContent = t_nm;
           filmIndexValue.textContent = n_film.toFixed(2);
           substrateIndexValue.textContent = n_sub.toFixed(2); // Update substrate display

           thinFilmCtx.clearRect(0, 0, width, height);

           // --- Calculate RGB Interference ---
           const resultR = calculateThinFilmInterference(t_nm, n_inc, n_film, n_sub, lambda_R);
           const resultG = calculateThinFilmInterference(t_nm, n_inc, n_film, n_sub, lambda_G);
           const resultB = calculateThinFilmInterference(t_nm, n_inc, n_film, n_sub, lambda_B);

           // Combine results for final color (scale intensity 0-1 to color value 0-255)
           const colorR = Math.round(resultR.intensity * 255);
           const colorG = Math.round(resultG.intensity * 255);
           const colorB = Math.round(resultB.intensity * 255);
           const reflectedColor = `rgb(${colorR}, ${colorG}, ${colorB})`;

           // Update color box and text description
           reflectedColorBox.style.backgroundColor = reflectedColor;
           interferenceText.innerHTML = `
                Red (${lambda_R}nm): ${getInterferenceDescription(resultR.intensity)}<br>
                Green (${lambda_G}nm): ${getInterferenceDescription(resultG.intensity)}<br>
                Blue (${lambda_B}nm): ${getInterferenceDescription(resultB.intensity)}
           `;

           // --- Draw Visual Diagram ---
           const airHeight = height * 0.2;
           const filmHeightRatio = 0.6; // Visual thickness ratio
           const filmHeight = height * filmHeightRatio;
           const subHeight = height * (1.0 - 0.2 - filmHeightRatio);
           const filmTopY = airHeight;
           const filmBottomY = airHeight + filmHeight;

           // Draw layers
           thinFilmCtx.fillStyle = 'rgba(173, 216, 230, 0.1)'; // Air
           thinFilmCtx.fillRect(0, 0, width, airHeight);
           thinFilmCtx.fillStyle = `rgba(200, 200, ${150 + n_film * 40}, 0.3)`; // Film color slightly depends on n
           thinFilmCtx.fillRect(0, filmTopY, width, filmHeight);
           thinFilmCtx.fillStyle = `rgba(${150 + n_sub * 10}, 160, 160, 0.4)`; // Substrate color slightly depends on n
           thinFilmCtx.fillRect(0, filmBottomY, width, subHeight);

           thinFilmCtx.fillStyle = '#000';
           thinFilmCtx.textAlign = 'left';
           thinFilmCtx.fillText(`Incident (n=${n_inc.toFixed(2)})`, 10, airHeight / 2 + 5);
           thinFilmCtx.fillText(`Film (n=${n_film.toFixed(2)}, t=${t_nm}nm)`, 10, filmTopY + filmHeight / 2);
           thinFilmCtx.fillText(`Substrate (n=${n_sub.toFixed(2)})`, 10, filmBottomY + subHeight / 2 + 5);

           // Draw simplified rays (normal incidence, slightly angled for visibility)
           const rayStartX = width * 0.4;
           const rayAngle = 0.15; // Slight angle for visual separation
           const dx = Math.sin(rayAngle);
           const dy = Math.cos(rayAngle); // Should be close to 1 for small angles

           // Incident ray
           thinFilmCtx.strokeStyle = 'black';
           thinFilmCtx.lineWidth = 1.5;
           thinFilmCtx.beginPath();
           thinFilmCtx.moveTo(rayStartX - airHeight * dx, 0);
           thinFilmCtx.lineTo(rayStartX, filmTopY);
           thinFilmCtx.stroke();
           thinFilmCtx.fillText("Incident Ray", rayStartX - airHeight * dx - 10 , 20);

           // Reflected ray 1 (R1) - from top surface
           const r1EndX = rayStartX - airHeight * dx;
           const r1EndY = 0;
           thinFilmCtx.strokeStyle = 'red';
           thinFilmCtx.beginPath();
           thinFilmCtx.moveTo(rayStartX, filmTopY);
           thinFilmCtx.lineTo(r1EndX, r1EndY);
           thinFilmCtx.stroke();
           thinFilmCtx.fillStyle = 'red';
           thinFilmCtx.fillText("R1", r1EndX - 15, r1EndY + 15);
           if (resultR.phaseShift1) { // Use R result, shifts are same for all wavelengths
               thinFilmCtx.fillText("180° shift", rayStartX - 50, filmTopY - 5);
           }

           // Ray inside film (down)
           const insideFilmX1 = rayStartX + filmHeight * dx / n_film; // Angle changes slightly inside
           thinFilmCtx.strokeStyle = 'gray';
           thinFilmCtx.setLineDash([3, 3]);
           thinFilmCtx.beginPath();
           thinFilmCtx.moveTo(rayStartX, filmTopY);
           thinFilmCtx.lineTo(insideFilmX1, filmBottomY);
           thinFilmCtx.stroke();

           // Ray inside film (up) - reflected from bottom
           const insideFilmX2 = insideFilmX1 - filmHeight * dx / n_film;
           thinFilmCtx.beginPath();
           thinFilmCtx.moveTo(insideFilmX1, filmBottomY);
           thinFilmCtx.lineTo(insideFilmX2, filmTopY);
           thinFilmCtx.stroke();
           thinFilmCtx.setLineDash([]); // Reset dash

            // Add Path difference label
            thinFilmCtx.fillStyle = 'purple';
            thinFilmCtx.fillText(`Optical Path Diff ≈ 2nt = ${resultR.pathDiff_nm.toFixed(0)} nm`, insideFilmX1 + 10, filmTopY + filmHeight / 2 );

           // Phase shift at bottom reflection label
           if (resultR.phaseShift2) {
               thinFilmCtx.fillText("180° shift", insideFilmX1 + 5, filmBottomY + 15);
           }


           // Reflected ray 2 (R2) - exiting film
           const r2StartX = insideFilmX2; // Where internal reflected ray hits top surface
           const r2EndX = r2StartX + airHeight * dx; // Exits parallel to R1
           const r2EndY = 0;
           thinFilmCtx.strokeStyle = 'blue';
           thinFilmCtx.beginPath();
           thinFilmCtx.moveTo(r2StartX, filmTopY);
           thinFilmCtx.lineTo(r2EndX, r2EndY);
           thinFilmCtx.stroke();
           thinFilmCtx.fillStyle = 'blue';
           thinFilmCtx.fillText("R2", r2EndX + 5, r2EndY + 15);

            // Combined Reflection Arrow
            thinFilmCtx.strokeStyle = reflectedColor; // Use the calculated color!
            thinFilmCtx.lineWidth = 4; // Make it thick
            thinFilmCtx.beginPath();
            const combinedX = (r1EndX + r2EndX)/2 + 40; // Position it slightly away
            thinFilmCtx.moveTo(combinedX, filmTopY - 10);
            thinFilmCtx.lineTo(combinedX, 10);
             // Arrowhead
             thinFilmCtx.lineTo(combinedX - 5, 15);
             thinFilmCtx.moveTo(combinedX, 10);
             thinFilmCtx.lineTo(combinedX + 5, 15);
            thinFilmCtx.stroke();
            thinFilmCtx.fillStyle = '#000';
            thinFilmCtx.fillText("Combined Reflection", combinedX - 40, filmTopY + 5);


       }

       // Event listeners
       filmThicknessSlider.addEventListener('input', drawThinFilmEnhanced);
       filmIndexSlider.addEventListener('input', drawThinFilmEnhanced);
       substrateIndexSlider.addEventListener('input', drawThinFilmEnhanced); // Add listener for substrate
       drawThinFilmEnhanced(); // Initial draw


         // --- 10.2 Single Slit Diffraction ---
         const singleSlitCanvas = document.getElementById('singleSlitCanvas');
         const singleSlitCtx = singleSlitCanvas.getContext('2d');
         const singleSlitLambdaSlider = document.getElementById('singleSlitLambdaSlider');
         const singleSlitWidthSlider = document.getElementById('singleSlitWidthSlider');
         const singleSlitLambdaValue = document.getElementById('singleSlitLambdaValue');
         const singleSlitWidthValue = document.getElementById('singleSlitWidthValue');

         function drawSingleSlitPattern() {
             const width = singleSlitCanvas.width;
             const height = singleSlitCanvas.height;
             const lambda = parseInt(singleSlitLambdaSlider.value) * 1e-9; // m
             const w = parseFloat(singleSlitWidthSlider.value) * 1e-3; // m
             const L = 1.0; // Screen distance = 1m
             const scale = width / 0.1; // Map +/- 5cm to canvas width

             singleSlitLambdaValue.textContent = singleSlitLambdaSlider.value;
             singleSlitWidthValue.textContent = singleSlitWidthSlider.value;

             singleSlitCtx.clearRect(0, 0, width, height);

              // Intensity calculation: I = I_0 * [sin(beta)/beta]^2, where beta = (pi * w * sin(theta)) / lambda
              function getSingleSlitIntensity(x_screen) {
                 const theta = Math.atan(x_screen / L);
                 if (w === 0 || lambda === 0) return 1.0;
                 const sin_theta = Math.sin(theta);
                 // Avoid division by zero if sin_theta is zero (center point)
                 if (Math.abs(sin_theta) < 1e-9) return 1.0;

                 const beta = (Math.PI * w * sin_theta) / lambda;
                 const sinc = Math.sin(beta) / beta;
                 const intensity = Math.pow(sinc, 2);
                 return intensity;
              }

              // Draw the intensity pattern
              singleSlitCtx.beginPath();
              singleSlitCtx.moveTo(0, height);
              for (let i = 0; i < width; i++) {
                  const x_canvas = i;
                  const x_screen = (x_canvas - width / 2) / scale;
                  const intensity = getSingleSlitIntensity(x_screen);
                  const y_canvas = height - intensity * (height - 10);
                  singleSlitCtx.lineTo(x_canvas, y_canvas);
              }
              singleSlitCtx.lineTo(width, height);
              singleSlitCtx.closePath();

             const color = wavelengthToColor(parseInt(singleSlitLambdaSlider.value));
             singleSlitCtx.fillStyle = color;
             singleSlitCtx.fill();

             // Draw center line
             singleSlitCtx.strokeStyle = '#aaa';
             singleSlitCtx.lineWidth = 1;
             singleSlitCtx.beginPath();
             singleSlitCtx.moveTo(width/2, 0);
             singleSlitCtx.lineTo(width/2, height);
             singleSlitCtx.stroke();
         }

         singleSlitLambdaSlider.addEventListener('input', drawSingleSlitPattern);
         singleSlitWidthSlider.addEventListener('input', drawSingleSlitPattern);
         drawSingleSlitPattern();


         // --- 10.3 Diffraction Grating ---
         const gratingCanvas = document.getElementById('gratingCanvas');
         const gratingCtx = gratingCanvas.getContext('2d');
         const gratingLambdaSlider = document.getElementById('gratingLambdaSlider');
         const gratingDSlider = document.getElementById('gratingDSlider');
         const gratingLambdaValue = document.getElementById('gratingLambdaValue');
         const gratingDValue = document.getElementById('gratingDValue');

         function drawGratingPattern() {
             const width = gratingCanvas.width;
             const height = gratingCanvas.height;
             const lambda = parseInt(gratingLambdaSlider.value) * 1e-9; // m
             const d = parseInt(gratingDSlider.value) * 1e-9; // m (grating spacing)
             const L = 1.0; // Screen distance = 1m
             const max_angle_rad = Math.PI / 3; // Limit drawing range to +/- 60 degrees

             gratingLambdaValue.textContent = gratingLambdaSlider.value;
             gratingDValue.textContent = gratingDSlider.value;

             gratingCtx.clearRect(0, 0, width, height);

             const color = wavelengthToColor(parseInt(gratingLambdaSlider.value));
             gratingCtx.fillStyle = color;
             gratingCtx.strokeStyle = '#aaa';
             gratingCtx.lineWidth = 1;

             // Draw center line
             gratingCtx.beginPath();
             gratingCtx.moveTo(width / 2, 0);
             gratingCtx.lineTo(width / 2, height);
             gratingCtx.stroke();

             // Calculate and draw positions of maxima (d sin(theta) = m * lambda)
             let m = 0;
             while (true) {
                 const sin_theta = (m * lambda) / d;
                 if (Math.abs(sin_theta) > Math.sin(max_angle_rad)) {
                     break; // Stop if angle is too large
                 }

                 if (Math.abs(sin_theta) <= 1) {
                     const theta = Math.asin(sin_theta);
                     const x_screen = L * Math.tan(theta); // Use tan for screen position

                     // Map screen position to canvas x coordinate (relative to center)
                     // Let's map +/- L*tan(max_angle) to the canvas width
                     const max_x_screen = L * Math.tan(max_angle_rad);
                     const x_canvas = width / 2 + (x_screen / max_x_screen) * (width / 2);

                      // Draw sharp peaks (simplified as vertical lines)
                      if (x_canvas >= 0 && x_canvas <= width) {
                         gratingCtx.beginPath();
                         gratingCtx.moveTo(x_canvas, height);
                         gratingCtx.lineTo(x_canvas, 10); // Draw line up to near top
                         gratingCtx.lineWidth = 3; // Make lines visible
                         gratingCtx.strokeStyle = color.replace('0.7', '1.0'); // Use solid color
                         gratingCtx.stroke();
                         gratingCtx.fillStyle = '#000';
                         gratingCtx.fillText(`m=${m}`, x_canvas - 5, height - 5);
                      }
                 }

                 if (m === 0) { m = 1; }
                 else if (m > 0) { m = -m; } // Draw negative order
                 else { m = -m + 1;} // Go to next positive order
             }
         }

         gratingLambdaSlider.addEventListener('input', drawGratingPattern);
         gratingDSlider.addEventListener('input', drawGratingPattern);
         drawGratingPattern();


         // --- 10.4 Electromagnetic Wave ---
         const emWaveCanvas = document.getElementById('emWaveCanvas');
         const emWaveCtx = emWaveCanvas.getContext('2d');
         const animateEMWaveButton = document.getElementById('animateEMWaveButton');
         const emWaveSpeedSlider = document.getElementById('emWaveSpeedSlider');
         let emWavePhase = 0;
         let emWaveAnimating = true;
         let lastTime = 0;

         function drawEMWave(timestamp) {
             const width = emWaveCanvas.width;
             const height = emWaveCanvas.height;
             const centerY = height / 2;
             const amplitude = height * 0.3;
             const wavelength = width / 4; // Show ~4 wavelengths
             const k = 2 * Math.PI / wavelength;
             const speed = parseFloat(emWaveSpeedSlider.value);

             if (!lastTime) lastTime = timestamp;
             const deltaTime = timestamp - lastTime;
             lastTime = timestamp;

             emWaveCtx.clearRect(0, 0, width, height);

             // Draw propagation axis
             emWaveCtx.strokeStyle = '#aaa';
             emWaveCtx.lineWidth = 1;
             emWaveCtx.beginPath();
             emWaveCtx.moveTo(0, centerY);
             emWaveCtx.lineTo(width, centerY);
             emWaveCtx.stroke();
             emWaveCtx.fillStyle = '#000';
             emWaveCtx.fillText("Direction of Propagation (x)", width - 150, centerY + 15);

             // Draw Electric Field (E - oscillating vertically, Blue)
             emWaveCtx.strokeStyle = 'blue';
             emWaveCtx.lineWidth = 2;
             emWaveCtx.beginPath();
             emWaveCtx.moveTo(0, centerY);
             for (let x = 0; x < width; x++) {
                 const y = centerY + amplitude * Math.sin(k * x - emWavePhase);
                 emWaveCtx.lineTo(x, y);
             }
             emWaveCtx.stroke();
             emWaveCtx.fillStyle = 'blue';
             emWaveCtx.fillText("E-Field (y)", 10, 20);


             // Draw Magnetic Field (B - oscillating horizontally, Red)
             // Simulate perspective for horizontal oscillation
             emWaveCtx.strokeStyle = 'red';
             emWaveCtx.lineWidth = 2;
             emWaveCtx.beginPath();
             emWaveCtx.moveTo(0, centerY);
              for (let x = 0; x < width; x++) {
                  // Cosine for 90deg phase diff, perspective scaling for 'z' axis
                  const z_oscillation = amplitude * Math.cos(k * x - emWavePhase);
                  const perspective_factor = 0.3; // How much perspective effect
                  const y = centerY + z_oscillation * perspective_factor * Math.sin(k*x); // Simple perspective approx
                  const lineWidthFactor = 1 + (z_oscillation / amplitude) * 0.5; // Thicker when 'closer'
                  emWaveCtx.lineWidth = 2 * lineWidthFactor;
                  emWaveCtx.lineTo(x, y); // Draw projected B field oscillation
                  emWaveCtx.stroke(); // Stroke segment by segment for varying line width
                  emWaveCtx.beginPath();
                  emWaveCtx.moveTo(x, y);
              }
             // Reset line width
             emWaveCtx.lineWidth = 2;
             emWaveCtx.fillStyle = 'red';
             emWaveCtx.fillText("B-Field (z)", 10, 40);


             if (emWaveAnimating) {
                 emWavePhase += speed * (deltaTime / 16); // Adjust phase based on speed and time elapsed
                 requestAnimationFrame(drawEMWave);
             }
         }

         animateEMWaveButton.addEventListener('click', () => {
            emWaveAnimating = !emWaveAnimating;
            animateEMWaveButton.textContent = emWaveAnimating ? 'Pause' : 'Animate';
            if (emWaveAnimating) {
                lastTime = 0; // Reset time for smooth restart
                requestAnimationFrame(drawEMWave);
            }
         });

         requestAnimationFrame(drawEMWave); // Start animation


         // --- 10.5 Polarization ---
         const polarizationCanvas = document.getElementById('polarizationCanvas');
         const polarizationCtx = polarizationCanvas.getContext('2d');
         const analyzerAngleSlider = document.getElementById('analyzerAngleSlider');
         const analyzerAngleValue = document.getElementById('analyzerAngleValue');
         const malusResult = document.getElementById('malusResult');

        function drawPolarization() {
            const width = polarizationCanvas.width;
            const height = polarizationCanvas.height;
            const centerY = height / 2;
            const sectionWidth = width / 4;
            const analyzerAngleDeg = parseInt(analyzerAngleSlider.value);
            const analyzerAngleRad = degreesToRadians(analyzerAngleDeg);

            analyzerAngleValue.textContent = analyzerAngleDeg;

            polarizationCtx.clearRect(0, 0, width, height);

             // 1. Unpolarized Light (Left Section)
             polarizationCtx.strokeStyle = '#888';
             polarizationCtx.lineWidth = 1;
             const rayY = centerY;
             polarizationCtx.beginPath();
             polarizationCtx.moveTo(0, rayY);
             polarizationCtx.lineTo(sectionWidth * 1.5, rayY); // Ray line
             polarizationCtx.stroke();

             // Draw 'starburst' for unpolarized
             const originX = sectionWidth * 0.5;
             const numLines = 12;
             const lineLength = 20;
             for (let i = 0; i < numLines; i++) {
                 const angle = (i / numLines) * Math.PI; // Only need 180 degrees coverage
                 polarizationCtx.beginPath();
                 polarizationCtx.moveTo(originX - lineLength * Math.cos(angle), rayY - lineLength * Math.sin(angle));
                 polarizationCtx.lineTo(originX + lineLength * Math.cos(angle), rayY + lineLength * Math.sin(angle));
                 polarizationCtx.stroke();
             }
             polarizationCtx.fillStyle = '#000';
             polarizationCtx.fillText("Unpolarized", sectionWidth * 0.5 - 30, height - 10);


             // 2. First Polarizer (Vertical)
             const polarizerX = sectionWidth * 1.5;
             polarizationCtx.fillStyle = 'rgba(100, 100, 100, 0.7)';
             polarizationCtx.fillRect(polarizerX - 10, 10, 20, height - 20); // Polarizer rectangle
             // Draw vertical transmission lines
             polarizationCtx.strokeStyle = '#fff';
             polarizationCtx.lineWidth = 1;
             for(let y = 15; y < height - 15; y += 5) {
                 polarizationCtx.beginPath();
                 polarizationCtx.moveTo(polarizerX, y);
                 polarizationCtx.lineTo(polarizerX, y + 3);
                 polarizationCtx.stroke();
             }
             polarizationCtx.fillStyle = '#000';
             polarizationCtx.fillText("Polarizer (Vertical)", polarizerX - 40, height - 10);


              // 3. Polarized Light (Middle Section)
              polarizationCtx.strokeStyle = '#888';
              polarizationCtx.lineWidth = 1;
              polarizationCtx.beginPath();
              polarizationCtx.moveTo(polarizerX + 10, rayY);
              polarizationCtx.lineTo(sectionWidth * 2.5, rayY); // Ray line
              polarizationCtx.stroke();

              // Draw vertical lines for vertically polarized light
              const polarizedX = sectionWidth * 2.0;
              polarizationCtx.strokeStyle = 'blue';
              polarizationCtx.lineWidth = 2;
               polarizationCtx.beginPath();
               polarizationCtx.moveTo(polarizedX, rayY - lineLength);
               polarizationCtx.lineTo(polarizedX, rayY + lineLength);
               polarizationCtx.stroke();
               polarizationCtx.fillStyle = '#000';
               polarizationCtx.fillText("Vertically Polarized", polarizedX - 50, height - 10);

              // 4. Analyzer
              const analyzerX = sectionWidth * 2.5;
              polarizationCtx.save(); // Save context state
              polarizationCtx.translate(analyzerX, centerY); // Move origin to analyzer center
              polarizationCtx.rotate(analyzerAngleRad); // Rotate the context
              polarizationCtx.fillStyle = 'rgba(100, 100, 100, 0.7)';
              polarizationCtx.fillRect(-10, -centerY + 10, 20, height - 20); // Analyzer rectangle (rotated)
              // Draw transmission lines aligned with analyzer angle
               polarizationCtx.strokeStyle = '#fff';
               polarizationCtx.lineWidth = 1;
               for(let y = -centerY + 15; y < centerY - 15; y += 5) {
                  polarizationCtx.beginPath();
                  polarizationCtx.moveTo(0, y);
                  polarizationCtx.lineTo(0, y + 3);
                  polarizationCtx.stroke();
               }
               polarizationCtx.restore(); // Restore context state
               polarizationCtx.fillStyle = '#000';
               polarizationCtx.fillText(`Analyzer (${analyzerAngleDeg}°)`, analyzerX - 30, height - 10);

               // 5. Output Light (Right Section) & Malus's Law
               const I0 = 1.0; // Assume initial polarized intensity is 1.0
               const I = I0 * Math.pow(Math.cos(analyzerAngleRad), 2);

               polarizationCtx.strokeStyle = '#888';
               polarizationCtx.lineWidth = 1;
               polarizationCtx.beginPath();
               polarizationCtx.moveTo(analyzerX + 10, rayY);
               polarizationCtx.lineTo(width, rayY); // Ray line
               polarizationCtx.stroke();

               // Draw output oscillation, scaled by sqrt(I) and rotated by analyzer angle
               const outputX = sectionWidth * 3.25;
               const outputAmplitude = lineLength * Math.sqrt(I);
               if (outputAmplitude > 1) { // Draw only if significant intensity
                    polarizationCtx.strokeStyle = 'red';
                    polarizationCtx.lineWidth = 2;
                    polarizationCtx.beginPath();
                    polarizationCtx.moveTo(outputX - outputAmplitude * Math.sin(analyzerAngleRad), rayY - outputAmplitude * Math.cos(analyzerAngleRad));
                    polarizationCtx.lineTo(outputX + outputAmplitude * Math.sin(analyzerAngleRad), rayY + outputAmplitude * Math.cos(analyzerAngleRad));
                    polarizationCtx.stroke();
               }
                polarizationCtx.fillStyle = '#000';
                polarizationCtx.fillText("Output", outputX - 20, height - 10);

                malusResult.textContent = `Output Intensity = I₀ * cos²(${analyzerAngleDeg}°) ≈ ${I.toFixed(2)} * I₀`;

        }
        analyzerAngleSlider.addEventListener('input', drawPolarization);
        drawPolarization();

        // --- Navigation Highlight ---
        const sections = document.querySelectorAll('section');
        const navLinks = document.querySelectorAll('nav a');

        window.onscroll = () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                // Adjust trigger point slightly below the sticky nav height
                if (pageYOffset >= sectionTop - 70) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        };

    </script>

</body>
</html>
